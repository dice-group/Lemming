package org.aksw.simba.lemming.mimicgraph.generator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import grph.Grph;

import org.aksw.simba.lemming.ColouredGraph;
import org.aksw.simba.lemming.metrics.dist.ObjectDistribution;
import org.aksw.simba.lemming.mimicgraph.colourmetrics.AvrgInDegreeDistBaseVEColo;
import org.aksw.simba.lemming.mimicgraph.colourmetrics.AvrgOutDegreeDistBaseVEColo;
import org.aksw.simba.lemming.mimicgraph.colourmetrics.TripleColourDistributionMetric;
import org.aksw.simba.lemming.mimicgraph.colourmetrics.utils.IOfferedItem;
import org.aksw.simba.lemming.mimicgraph.colourmetrics.utils.OfferedItemByRandomProb;
import org.aksw.simba.lemming.mimicgraph.colourmetrics.utils.PoissonDistribution;
import org.aksw.simba.lemming.mimicgraph.constraints.TripleBaseSetOfIDs;
import org.aksw.simba.lemming.mimicgraph.constraints.TripleBaseSingleID;
import org.aksw.simba.lemming.util.Constants;
import org.aksw.simba.lemming.util.RandomUtil;
import org.apache.jena.ext.com.google.common.primitives.Doubles;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.carrotsearch.hppc.BitSet;
import com.carrotsearch.hppc.ObjectObjectOpenHashMap;

import grph.DefaultIntSet;
import it.unimi.dsi.fastutil.ints.IntSet;

/*
 * Graph generation based on the probability of Vertices calculated based on the weights assigned to them. 
 * The weights which are assigned to the single vertices are generated by the Knuth's Poisson Distribution Algorithm.
 * 
 * @author Abhilash Kandarpa (abhilash@mail.uni-paderborn.de)
 * 
 * */

public class BiasedGraphGenerator extends AbstractGraphGeneration implements IGraphGeneration {

	private static final Logger LOGGER = LoggerFactory.getLogger(BiasedGraphGenerator.class);

	private Map<BitSet, Map<BitSet, Map<BitSet, TripleBaseSetOfIDs>>> mTrippleMapOfTailHeadEdgeRates;
	private List<TripleColourDistributionMetric> mLstEVColorMapping;
	private Map<Integer, List<BitSet>> mMapEdgeIdsToTripleColours;

	protected ObjectObjectOpenHashMap<BitSet, ObjectObjectOpenHashMap<BitSet, IOfferedItem<Integer>>> mapPossibleODegreePerOEColo;
	protected ObjectObjectOpenHashMap<BitSet, ObjectObjectOpenHashMap<BitSet, IOfferedItem<Integer>>> mapPossibleIDegreePerIEColo;

	public BiasedGraphGenerator(int iNumberOfVertices, ColouredGraph[] origGrphs, int iNumberOfThreads, long seed) {
		super(iNumberOfVertices, origGrphs, iNumberOfThreads, seed);
		// TODO Auto-generated constructor stub
		LOGGER.warn("Inside the BiasedGraphGenerator Method!!! ");
		// Find a class of the head and tail vertices.
		// After the classes of the vertices are fixed then compute a statistic from the
		// events of the previously existing vertices of the graph.
		// Let the statistic be Poisson distribution generated variable from the events
		// of the previous vertices.
		// Assign the variable value as a weight to the chosen vertex.
		mTrippleMapOfTailHeadEdgeRates = new HashMap<BitSet, Map<BitSet, Map<BitSet, TripleBaseSetOfIDs>>>();
		
	}

	public ColouredGraph generateGraph(ColouredGraph[] graph){
		if(mNumberOfThreads == 1){
			LOGGER.info("Run graph generation with single thread!");
			generateGraphSingleThread();
		}else{
			LOGGER.info("Run graph generation with "+mNumberOfThreads+ " threads!");
			mNumberOfThreads = 1;
			generateGraphSingleThread();
		}
		return mMimicGraph;
	}
	
	private static int getPoissonRandom(double mean) {
		Random r = new Random();
		double L = Math.exp(-mean);
		int k = 0;
		double p = 1.0;
		do {
			p = p * r.nextDouble();
			k++;
		} while (p > L);
		return k - 1;
	}

	// This method generates a random graph. We have to modify this using the
	// Poisson Distribution.
	private void generateGraphSingleThread() {
		Set<BitSet> setVertColo = mMapColourToVertexIDs.keySet();

		for (BitSet tailColo : setVertColo) {
			LOGGER.info("Tail Color : "+ setVertColo);
			Map<BitSet, Map<BitSet, TripleBaseSetOfIDs>> mapHeadEdgeToGrpTriples = null;
			try {
				mapHeadEdgeToGrpTriples = mTrippleMapOfTailHeadEdgeRates.get(tailColo);
			}
			catch(NullPointerException e) {
				LOGGER.info("Catching null pointer Exception here at 106 "+mapHeadEdgeToGrpTriples+ ";"+ tailColo );
				//continue;
			}
			/*
			 * if (mapHeadEdgeToGrpTriples == null) continue;
			 */

			for (BitSet headColo : setVertColo) {
				LOGGER.info("Head Color : "+ setVertColo);
				if (mapHeadEdgeToGrpTriples.containsKey(headColo)) {

					Map<BitSet, TripleBaseSetOfIDs> mapEdgeToGrpTriples = mapHeadEdgeToGrpTriples.get(headColo);

					if (mapEdgeToGrpTriples == null)
						continue;

					Set<BitSet> setEdgeColours = mapEdgeToGrpTriples.keySet();

					for (BitSet edgeColo : setEdgeColours) {
						TripleBaseSetOfIDs triple = mapEdgeToGrpTriples.get(edgeColo);

						if (triple != null && triple.edgeIDs.size() > 0) {
							double noOfEdges = triple.edgeIDs.size();

							ObjectObjectOpenHashMap<BitSet, IOfferedItem<Integer>> mapTailIdProposers = mapPossibleODegreePerOEColo
									.get(edgeColo);
							ObjectObjectOpenHashMap<BitSet, IOfferedItem<Integer>> mapHeadIdProposers = mapPossibleIDegreePerIEColo
									.get(edgeColo);

							IntSet setOfRandomTailIds = getRandomVerticesWithDegree(triple.tailColour, triple.noOfTails,
									mapTailIdProposers);
							IntSet setOfRandomHeadIds = getRandomVerticesWithDegree(triple.headColour, triple.noOfHeads,
									mapHeadIdProposers);

							if ((setOfRandomHeadIds == null || setOfRandomHeadIds.size() == 0)
									|| (setOfRandomTailIds == null || setOfRandomTailIds.size() == 0)) {
								LOGGER.error("There exists no vertices in " + triple.tailColour + " or "
										+ triple.headColour + " colour");
								continue;
							}

							IOfferedItem<Integer> tailIdsProposer = mapTailIdProposers.get(triple.tailColour);
							IOfferedItem<Integer> headIdsProposer = mapHeadIdProposers.get(triple.headColour);

							triple.headIDs.addAll(setOfRandomHeadIds);
							triple.tailIDs.addAll(setOfRandomTailIds);

							Set<Integer> setTailIds = new HashSet<Integer>();
							setTailIds.addAll(setOfRandomTailIds);
							Set<Integer> setHeadIds = new HashSet<Integer>();
							setHeadIds.addAll(setOfRandomHeadIds);

							/*
							 * Till this point we have the list of all HeadIDs in setHeadIds and all TailIDs
							 * in setTailIds. We have to find out the mean of the all the degrees of head
							 * and tail IDs and run those through the Poisson Distribution function in order
							 * to generate a random number that we can assign as a weight to a single
							 * vertex. Repeat the process until there are no single vertices left in
							 * triple.headIds or triple.tailIds. Then using the weights calculate the
							 * probability of each vertex to be chosen for sampling.
							 */
							ColouredGraph graph = new ColouredGraph();
							double hmean = 0.0, tmean = 0.0;
							int hcount = 0, tcount = 0;
							HashMap<Integer, Integer> setHeadSingles = new HashMap<Integer, Integer>();
							HashMap<Integer, Integer> setTailSingles = new HashMap<Integer, Integer>();
							Iterator<Integer> hitr = setHeadIds.iterator();
							Iterator<Integer> titr = setTailIds.iterator();
							while (hitr.hasNext() || titr.hasNext()) {
								if (hitr.hasNext()) {
									if (graph.getGraph().getOutEdgeDegree(hitr.next()) > 0) {
										hmean = hmean + graph.getGraph().getOutEdgeDegree(hitr.next());
										hcount++;
									} else {
										setHeadSingles.put(hitr.next(), null);
									}
								}
								if (titr.hasNext()) {
									if (graph.getGraph().getInEdgeDegree(titr.next()) > 0) {
										tmean = tmean + graph.getGraph().getInEdgeDegree(titr.next());
										tcount++;
									} else {
										setTailSingles.put(titr.next(), null);
									}
								}
							}
							hmean = hmean / hcount;
							tmean = tmean / tcount;
							assignWeights(hmean, tmean, setHeadSingles, setTailSingles);
							/*
							 * standardize the amount of edges and vertices this makes sure there is no pair
							 * of vertices are connected by 2 edges in same colour
							 */
							/*
							 * if(setHeadIds.size() * setTailIds.size() < noOfEdges){
							 * LOGGER.warn("Not generate " + (noOfEdges - (setHeadIds.size() *
							 * setTailIds.size())) + " edges in "+ edgeColo ); noOfEdges = setHeadIds.size()
							 * * setTailIds.size(); }
							 * 
							 * int headId = -1; int i = 0 ; while(i < noOfEdges){
							 * 
							 * setOfRandomHeadIds = new DefaultIntSet(triple.headIDs.size());
							 * setOfRandomHeadIds.addAll(triple.headIDs);
							 * 
							 * // select a random tail int tailId =
							 * tailIdsProposer.getPotentialItem(setTailIds);
							 * 
							 * int[] arrConnectedHeads = getConnectedHeads(tailId, edgeColo).toIntArray();
							 * for(int connectedHead: arrConnectedHeads){
							 * if(setOfRandomHeadIds.contains(connectedHead))
							 * setOfRandomHeadIds.remove(connectedHead); }
							 * 
							 * if(setOfRandomHeadIds.size() == 0 ){
							 * LOGGER.warn("No heads any more! Consider another tail"); continue; }
							 * Set<Integer> setFilteredHeadIDs = new HashSet<Integer>(setOfRandomHeadIds);
							 * 
							 * headId = headIdsProposer.getPotentialItem(setFilteredHeadIDs);
							 * 
							 * if(connectableVertices(tailId, headId, triple.edgeColour)){
							 * mMimicGraph.addEdge(tailId, headId, edgeColo); i++; }
							 *
							 * }// end while
							 */
						}
					}
				}
			}
		}
	}

	private void assignWeights(Double hmean, Double tmean, HashMap<Integer, Integer> setHeadSingles,
			HashMap<Integer, Integer> setTailSingles) {

		int total_weight = 0;
		
		LOGGER.info("Head mean : "+ hmean+ "Tail mean : "+ tmean);
		for (int id : setHeadSingles.keySet()) {
			int weight = getPoissonRandom(hmean);
			setHeadSingles.replace(id, weight);
			total_weight = total_weight + weight;
			LOGGER.info("Head vertices and their weights : "+ setHeadSingles.get(id)+ ";"+ setHeadSingles.get(weight));
		}
		getProbability(setHeadSingles, total_weight);
		total_weight = 0;

		for (int id : setTailSingles.keySet()) {
			int weight = getPoissonRandom(tmean);
			setTailSingles.replace(id, weight);
			total_weight = total_weight + weight;
			LOGGER.info("Tail vertices and their weights : "+ setTailSingles.get(id)+ ";"+ setTailSingles.get(weight));
		}
		getProbability(setTailSingles, total_weight);
	}

	private void getProbability(HashMap<Integer, Integer> setSingles, int weight) {

		HashMap<Integer, Double> VertexList = new HashMap<Integer, Double>();

		for (int id : setSingles.keySet()) {
			double probability = (setSingles.get(id) / weight);
			VertexList.put(id, probability);
		}
	}

	private IntSet getRandomVerticesWithDegree(BitSet vertColo, double iNoOfVertices,
			ObjectObjectOpenHashMap<BitSet, IOfferedItem<Integer>> mapVertexIdsProposers) {
		IntSet setVertices = new DefaultIntSet(mMapColourToVertexIDs.get(vertColo).size());
		setVertices.addAll(mMapColourToVertexIDs.get(vertColo));

		// invalid setVertices
		if (setVertices == null || setVertices.size() == 0)
			return null;

		Set<Integer> tmpSetOfVertices = new HashSet<Integer>(setVertices);
		IOfferedItem<Integer> vertexIdsProposer = mapVertexIdsProposers.get(vertColo);

		if (vertexIdsProposer != null) {
			int[] arrVertices = setVertices.toIntArray();
			IntSet res = new DefaultIntSet(Constants.DEFAULT_SIZE);

			if (iNoOfVertices >= arrVertices.length) {
				iNoOfVertices = arrVertices.length;
				return setVertices;
			}

			while (iNoOfVertices > 0) {
				int vertId = vertexIdsProposer.getPotentialItem(tmpSetOfVertices);
				if (!res.contains(vertId) && !mReversedMapClassVertices.containsKey(vertId)) {
					res.add(vertId);
					iNoOfVertices--;
					tmpSetOfVertices.remove(vertId);
				}

				if (tmpSetOfVertices.size() == 0) {
					LOGGER.warn("Could not found more " + iNoOfVertices + " vertices of " + vertColo);
					break;
				}

				boolean havingMore = false;
				Iterator<Integer> iter = tmpSetOfVertices.iterator();
				while (iter.hasNext()) {
					int availableId = iter.next();
					if (!mReversedMapClassVertices.containsKey(availableId) && !res.contains(availableId)) {
						havingMore = true;
						break;
					}
				}

				if (!havingMore) {
					LOGGER.warn("Could not get " + iNoOfVertices + " vertices of " + vertColo);
					break;
				}
			}

			return res;
		}
		return null;
	}

}
